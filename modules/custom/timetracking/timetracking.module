<?php

/**
 * @file
 * Module for the timetracking Entity - developed within ERPAL
 */  

module_load_include('inc', 'timetracking', 'timetracking.entity');   
module_load_include('inc', 'timetracking', 'timetracking.admin'); 
 
/**
 * Implements hook_views_api().
 */
function timetracking_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'timetracking') . '/views',
  );
} 

/**
* Implements hook_menu
*/ 
function timetracking_menu(){

  $items = array();
  
  $items['timetracking/toggle/%/%/%'] = array(
    'page callback' => '_timetracking_toggle',
    'page arguments' => array(2,3,4), //entity_type, subject nid, next_state [on, off]
    'access callback' => '_timetracking_toggle_access',
    'access arguments' => array(2,3), //entity_type, subject_nid
    'type' => MENU_CALLBACK,
  );

  return $items;
} 
 
/**
 * Implements hook_block_info().
 */
function timetracking_block_info() {
  return array(
    'block' => array(
      'info' => t('Timetracking'),
    ),
    'last_timetracking_block' => array(
      'info' => t('Last timetracking'),
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function timetracking_block_view($delta) {
  global $user;
  if (!(user_access('use quick timetracking') || user_access('create timetracking'))) {
    return NULL;
  };

  if ($delta == 'last_timetracking_block' ) {
    $block['subject'] = '';
    $block['content'] = _timetracking_last_timetracking_block_render($user->uid);
  } else {
    $block['subject'] = t('Quick timetracking');
    $block['content'] = drupal_get_form('timetracking_quick_form');
  }
  return $block;
}

/**
* renders a block html for the last timetracking of a user, if one is available
*/
function _timetracking_last_timetracking_block_render($uid) {
  
  if (!$uid)
    return false;
  
  $last_timetracking = _timetrackings_by_user_latest($uid);
  $lt = $last_timetracking;
  
  $subject_id = $lt->subject_id ? $lt->subject_id : md5($lt->description);
  $state = $lt->time_end ? 'off' : 'on';
  
  //get total duration of all timetrackings to the given subject
  if (is_numeric($subject_id))
    $total_duration = _timetracking_get_total_duration_by_subject_by_user($uid, $subject_id);
  else
    $total_duration = $lt->duration;
  
  $duration = round($total_duration, 2);
  //@TODO make this work not only for entity type of node. Therefor we have to save the entity type in the database, @see _timetracking_calculate_current_timetrackings#
  $node_titles = erpal_lib_helper_node_titles(array($lt->subject_id));
  $subject_title = $lt->subject_id ? $node_titles[$lt->subject_id] : $lt->description;
  $timetracking_button = "<div class='last_timetracking'><span class='timetracking_subject'>".$subject_title."</span>".theme('timetracking_button', array('entity_type' => 'node', 'entity_id' => $subject_id, 'state' => $state, 'duration' => $duration))."</div>";

  return $timetracking_button;
}

/**
* Returns the total sum of all timetrackings of a given subject by a given user.
* subject could be an MD5 has or a numeric id, which depends on the fact if the timetracking has a subject-ID assigned or not.
*/
function _timetracking_get_total_duration_by_subject_by_user($uid, $subject_id) {
  $timetracking_nids = _timetrackings_by_user($uid, $subject_id);
  $timetrackings = timetracking_load_multiple($timetracking_nids);
  
  $duration = 0;
  foreach ($timetrackings as $timetracking) {
    $duration += $timetracking->duration;
  }
  
  return round($duration, 2);
}

/**
* For for adding quick timetracking
*/
function timetracking_quick_form($form, $form_state) {
  global $user;
  
  $form = array();

  $form['subject'] = array(
    '#type' => 'textfield',
    '#title' => t('What?'), 
    '#size' => 15,
    '#weight' => 10
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Track'), 
    '#weight' => 20,
    '#ajax' => array(
      'callback' => '_timetracking_ajax_track_submit',
      'wrapper' => 'timetracking_block_timetrackings_wrapper',
      'effect' => 'fade',
      'method' => 'replace',
    ),
  );
  
  $form['timetrackings'] = array(
    '#type' => 'fieldset',
    '#collapsible' => false,
    '#collapsed' => false,
    '#prefix' => '<div id="timetracking_block_timetrackings_wrapper">',
    '#suffix' => '</div>',
    '#weight' => 30,
  );
  
  //order timetrackings that have a subject and the ones that dont have a subject      
  $form['timetrackings']['with_subject'] = array(
    '#type' => 'fieldset',
    '#title' => t('With subject'),
    '#collapsible' => false,
    '#collapsed' => false,
  );
  
  $form['timetrackings']['without_subject'] = array(
    '#type' => 'fieldset',
    '#title' => t('Without subject'),
    '#collapsible' => false,
    '#collapsed' => false,
  );
  
  //add timetracking to fieldsets
  $grouped_trackings = _timetracking_calculate_current_timetrackings();

  $with_subject = $grouped_trackings['with_subject'];
  $without_subject = $grouped_trackings['without_subject'];
  $with_subject_for_list = array();
  foreach ($with_subject as $subject_id=>$data) {
    $subject = $data['subject'];

    $duration = round($data['total_duration'],2);
    $subject_link = l($subject->title, 'node/'.$subject->nid);
    $with_subject_for_list[] = $subject_link.theme('timetracking_button', array('entity_type' => 'node', 'entity_id' => $subject_id, 'state' => $data['state'], 'duration' => $duration));
  }
  
  $without_subject_for_list = array();
  foreach ($without_subject as $description=>$data) {    
    $duration = round($data['total_duration'],2);
    $without_subject_for_list[] = $description.theme('timetracking_button', array('entity_type' => 'node', 'entity_id' => md5($description), 'state' => $data['state'], 'duration' => $duration));
  }

  if (count($with_subject)) {
    //for each fieldset a list
    $variables = array(
      'items' => $with_subject_for_list,
    );
    $form['timetrackings']['with_subject']['timetrackings'] = array(
      '#type' => 'item',
      '#markup' => theme('item_list', $variables),
    );
  }
    
  if (count($without_subject)) {
    $variables = array(
      'items' => $without_subject_for_list,
    );
    $form['timetrackings']['without_subject']['timetrackings'] = array(
      '#type' => 'item',
      '#markup' => theme('item_list', $variables),
    );
  }
  
  
  
  
  //add javascript
  _timetracking_add_track_js();
  
  return $form;
}

/**
* Validation handler for timetracking form
*/
function timetracking_quick_form_validate($form, $form_state) {
  //@TODO validate timetracking subject
  $values = $form_state['values'];
  $subject = $values['subject'];
  
  if (!$subject) form_set_error('subject', t('Please add a subject'));
  
  //check if there is a nid if the user is allowed to use this node. @TODO actually it doesnt work with all entities, only with nodes
  $subject_nid = _timetracking_get_nid_from_autocomplete_string($subject);
  if ($subject_nid) {
    $subject_node = node_load($subject_nid);
    if (!node_access('view', $subject_node) || !$subject_node->nid)
      form_set_error('subject', 'You are not allowed to use this node');
  }
}

/**
* Submit handler for timetracking form
*/
function timetracking_quick_form_submit($form, $form_state) {
  global $user;
  $values = $form_state['values'];
  $subject = check_plain($values['subject']);
  
  //if subject has entity reference syntax we use the nid as subject
  $subject_nid = _timetracking_get_nid_from_autocomplete_string($subject);
  
  //stop all other timetrackings by the user
  
  if (!$subject_nid) {
    //create a new timetracking without a subject
    timetracking_create_new(time(), $user->uid, $subject, $subject_nid);
  } else {
    //create a new timetracking with subject_nid
    $subject_node = node_load($subject_nid);
    $description = _timetracking_default_description($subject_node);
    timetracking_create_new(time(), $user->uid, $description, $subject_nid);
  }  
  
}


/**
* Handler to output form element that should be replaced or added using ajax framework
*/
function _timetracking_ajax_track_submit($form, $form_state) {
  //recreate the form but without drupal get form. Otherwise, the new timetracking will not be shown in the list because of cache
  $new_form = timetracking_quick_form($form, $form_state);

  return $new_form['timetrackings'];
}

/**
* Prepares the timetrackings for the quick timetracking so that every subject has a sum of all timetrackings
* @return an array with keys "with_subject" and "without_subject" containing arrays of timetrackings with metadata like total_duration etc.
*/
function _timetracking_calculate_current_timetrackings() {
  global $user;
  
  //get list of all timetrackings by current user
  $timetracking_nids = _timetrackings_by_user($user->uid);
  $timetrackings = timetracking_load_multiple($timetracking_nids);
  
  $with_subject = array();
  $without_subject = array();
  foreach ($timetrackings as $timetracking) {    
    
    $subject_id = $timetracking->subject_id;

    //get the state
    if ($timetracking->time_end) {
      $state = 'off';
    } else {
      $state = 'on';
    }

    $init_data = array('total_duration'=>0, 'state'=>'off', 'subject'=>false); //initialise data array
    $duration = $timetracking->time_end ? $timetracking->duration : (time() - $timetracking->time_start) / (60*60);
    if ($subject_id) {
      $subject = node_load($subject_id);//@TODO make this compatible with all entitys and save the entity type into the datebase of timetrackings
      
      //group them by subject
      if (isset($with_subject[$subject_id]) && $with_subject[$subject_id]) {
        $data = $with_subject[$subject_id];        
      } else
        $data = $init_data;
      
      $data['total_duration'] += $duration;
      if ($state == 'on')
        $data['state'] = 'on'; //if one is "on" (and there should always be only one "on", it could not be off.
      
      $data['subject'] = $subject;
      
      $with_subject[$subject_id] = $data;
    } else {      
      //if there is no subject, group by description
      $description = $timetracking->description;
      if (isset($without_subject[$description]) && $without_subject[$description]) {
        $data = $without_subject[$description];        
      } else
        $data = $init_data;
            
      $data['total_duration'] += $duration;
      if ($state == 'on')
        $data['state'] = 'on'; //if one is "on" (and there should always be only one "on", it could not be off.
      
      $data['subject'] = false;
      
      $without_subject[$description] = $data;
    }
  }

  return array(
    'with_subject' => $with_subject,
    'without_subject' => $without_subject,
  );
}
 
/**
* Function that toggles the timetracking for a entity as subject
*/
function _timetracking_toggle($entity_type, $subject_id, $new_state) {
  global $user;
  
  //check if we have a real subject or just a md5 checksum of the description
  if (!is_numeric($subject_id)) {
    //so this is toggeling. Means we have already a timetracking entity with the same description. So letzt find it und use the discription of the existing timetracking entity
    $description = _timetracking_get_timetracking_description_by_checksum_by_user($subject_id, $user->uid);
    
    $subject_id = false; //because it is no real subject_id so it willbe handled like no subject_id would be available
  }
  
  if ($new_state == 'on') {
    //toggle on    
    //get the entity
    $entity = entity_load('node', array($subject_id));
    $entity = $entity[$subject_id];
    if ($subject_id)
      $description = _timetracking_default_description($entity);
    timetracking_create_new(time(), $user->uid, $description, $subject_id);
  } else {
    //toggle off
    //get the timetracking that are "on" and stop them
    $timetrackings = _timetrackings_by_user($user->uid, $subject_id, false);
    foreach ($timetrackings as $timetracking_id) {
      $timetracking = timetracking_load($timetracking_id);
      $timetracking->close();
    }
  }
}

/**
* Returns a description of timetrackings that have match the md5 of their descrition with the given checksum
*/
function _timetracking_get_timetracking_description_by_checksum_by_user($checksum, $uid) {
  $timetracking_nids = _timetrackings_by_user($uid);
  $timetrackings = timetracking_load_multiple($timetracking_nids);
  
  foreach ($timetrackings as $timetracking) {
    $md5_description = md5($timetracking->description);
    if ($md5_description == $checksum)
      return $timetracking->description;
  }
  
  return false;  //no description found...should not happen!
}

/**
* Get default description for timetrackings
*/
function _timetracking_default_description($node) {
  return t('Work on !subject_title', array('!subject_title' => $node->title)); //@todo ->title is not for every entity, so make it generic with e.g. get_label or something equal
}

/**
* Access callback for timetracking toggle path
*/
function _timetracking_toggle_access($entity_type, $subject_id) {

  if ($entity_type == 'node')
    $node = node_load($subject_id);
  
  //return node_access('view', $node);
  return true; //@todo validation like tries with node access, but doesnt work..!
}
 
/**
 * Implement hook_entity_info().
 *
 * We define our entities here - the actual entity that will hold our domain
 * specific information 
 */
function timetracking_entity_info() {
  $return['timetracking'] = array(
    'label' => t('timetracking'),
    // The entity class and controller class extend the classes provided by the
    // Entity API
    'entity class' => 'timetracking',
    'controller class' => 'timetrackingController',
    'base table' => 'timetracking',
    'file' => 'timetracking.entity.inc',
    'fieldable' => TRUE,
    'entity keys' => array(
        'id' => 'timetracking_id',
        'bundle' => 'type',
    ),   
    'bundles' => array(
      'timetracking'=> array(
        'label' => 'timetracking',        
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'creation callback' => 'timetracking_create',
    'access callback' => 'timetracking_access',
    'module' => 'timetracking',
    // The information below is used by the timetrackingUIController (which extends the EntityDefaultUIController)
    'admin ui' => array(
      'path' => 'admin/content/timetrackings',
      'file' => 'timetracking.admin.inc',
      'controller class' => 'timetrackingUIController',
      'menu wildcard' => '%timetracking',
    ),
  );

  return $return;
}
 
 
/**
 * Implements hook_permission().
 */
function timetracking_permission() {
  // We set up permisssions to manage entity types, manage all entities and the
  // permissions for each individual entity
  $permissions = array(
    'create timetracking' => array(
      'title' => t('Create timetracking'),
    ),
    'administer timetrackings' => array(
      'title' => t('Administer all timetrackings'),
    ),
    'edit any timetracking' => array(
      'title' => t('Edit any timetracking'),
    ),
    'edit own timetracking' => array(
      'title' => t('Edit own timetracking'),
    ),
    'delete any timetracking' => array(
      'title' => t('Delete any timetracking'),
    ),
    'delete own timetracking' => array(
      'title' => t('Delete own timetracking'),
    ),
    'view any timetracking' => array(
      'title' => t('View any timetracking'),
    ),  
    'use quick timetracking' => array(
      'title' => t('Use quick timetracking'),
    ),
  );
  
  return $permissions;  
}


/**
 * Determines whether the given user has access to a timetracking.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param $timetracking
 *   Optionally a timetracking or a timetracking type to check access for. If nothing is
 *   given, access for all timetrackings is determined.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 * @return boolean
 *   Whether access is allowed or not.
 */
function timetracking_access($op, $timetracking = NULL, $account = NULL) {

  global $user;
  if (!$account)
    $account = $user;
    
  if (user_access('administer timetrackings', $account)) {
    return TRUE;
  }

  if (isset($timetracking) && is_object($timetracking)) {
    $op = ($op == 'view') ? 'view' : 'edit';

    if (isset($timetracking->timetracking_id) && $account->uid == $timetracking->uid) {
      if (user_access("$op own timetracking", $account)) {
        return TRUE;
      }
    }
    
    if (user_access("$op any timetracking", $account)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implement hook_theme().
 */
function timetracking_theme() {
  //themes for our timetracking entity
  require_once('timetracking.entity.inc');
  $themes = _timetracking_entity_theme();
  
  $themes['timetracking_button'] = array(
    'variables' => array('entity_type' => false, 'entity_id' => array(), 'state' => false, 'duration' => false, 'start_label' => false, 'stop_label' => false),
    'template' => 'template/timetracking_button',
  );
  
  return $themes;
}  

/**
* So we can make the user change the date format by changing this variable 
*/
function _timetracking_get_date_format($time = true){
  if (module_exists('erpal_invoice_helper')) {
    if (!$time)
      return _erpal_basic_helper_date_format_date_only();
    else
      return _erpal_basic_helper_date_format_date_time();
  } else {  
    if (!$time)
      return variable_get('date_format_short_date_only', 'Y/m/d');
    else
      return variable_get('date_format_short_date_time', 'Y/m/d H:i');
  }
}


/**
 * Implements hook_references_dialog_entity_admin_paths().
 * Needed to provide a link path to create a new timetracking at an entity reference field in reference dialog widget
 */
function timetracking_references_dialog_entity_admin_paths() {
  // We define the add and edit page callbacks for core entities here.
  $admin_paths = array(
    'timetracking' => array(
      'add' => 'timetracking/add',
      'edit' => 'timetracking/[entity_id]/edit',
    ),
  );
  return $admin_paths;
}

/**
* Function to quick create a new timetracking entity
*/
function timetracking_create_new($time_start, $uid, $description=false, $subject_id=false) {
  $timetracking_controler = entity_get_controller('timetracking');
  $values = array();
  
  //stop all other timetrackings of the user
  _timetracking_stop_other_user_times($uid);
  
  $timetracking_entity = $timetracking_controler->create($values);
  $timetracking_entity->time_start = $time_start;
  $timetracking_entity->uid = $uid;
  $timetracking_entity->description = $description;
  $timetracking_entity->subject_id = $subject_id;
  $timetracking_entity->created = time();
  $timetracking_entity->save();
  
  return $timetracking_entity;
}

/**
* Stops all other user timetracking entities
*/
function _timetracking_stop_other_user_times($uid) {
  $timetracking_nids = _timetrackings_by_user($uid);
  $timetrackings = timetracking_load_multiple($timetracking_nids);
  
  //now close them
  foreach ($timetrackings as $timetracking) {
    $timetracking->close();
  } 
}



/**
* Returns all timetrackings by a given user
* @param $need_time_end if true, we only return timetrackings that don't have a end time set
*/
function _timetrackings_by_user($uid, $subject_id=false, $need_time_end=false) {
  $query = db_select('timetracking', 't')
  ->fields('t', array('timetracking_id'))
  ->condition('uid', $uid, '=');
  
  if ($subject_id) {
    $query->condition('subject_id', $subject_id, '=');
  }
  
  if ($need_time_end) {
    $query->condition('time_end', 0, '=');
  }
  
  $result = $query->execute()
  ->fetchAll();
  
  //load all timetracking entities
  $entities = array();
  
  foreach ($result as $obj) {
    $entities[] = $obj->timetracking_id;
  }
  
  return $entities;
}

/**
* Returns the latest timetracking by a given user
*/
function _timetrackings_by_user_latest($uid) {
  
  if (!$uid)
    return false;
  
  $query = db_select('timetracking', 't')
  ->fields('t', array('timetracking_id'))
  ->condition('uid', $uid, '=')
  ->orderBy('changed', 'desc')
  ->range(0,1);
  
  $result = $query->execute()
  ->fetchAll();
  $object = reset($result);
  if ($object) {
    $timetracking = timetracking_load($object->timetracking_id);
    return $timetracking;
  }

  return false;
}

/**
* Returns all posaible entities that could be referenzed by a timetracking. This is dann by each module implementing the provided hook
*/
function _timetracking_get_possible_timetracking_subjects() {
  $subjects = module_invoke_all('possible_timetracking_subjects');

  //each module sets his list into a spearate array
  $ret = array();
  foreach ($subjects as $subject_arr) {
    foreach ($subject_arr as $id=>$title) {
      $ret[$id] = $title;
    }
  }
  
  return $ret;
}

/**
* preprocess function for timetracking button
*/
function template_preprocess_timetracking_button(&$variables) {
  //add timetracking script
  _timetracking_add_track_js();
  
  $state = $variables['state'];
  $entity_type = $variables['entity_type'];
  
  //prepare some path of images
  $mod_path = drupal_get_path('module', 'timetracking');
  $image_path = '/'.$mod_path.'/image';
  $path_start = $image_path.'/control_play.png';
  $path_stop = $image_path.'/control_stop.png';
  
  $start_text = t('Start');
  $stop_text = t('Stop');
  if (isset($variables['start_label']) && $variables['start_label'])
    $start_text = $variables['start_label'];
    
  if (isset($variables['stop_label']) && $variables['stop_label'])
    $stop_text = $variables['stop_label'];
    
  if ($state=='on') {
    $image = $path_stop;
    $linktext = $stop_text;
  }else{
    $image = $path_start;
    $linktext = $start_text;
  }

  //add the image paths to javascript variables to script can use them!
  $togglevalues = array(
    'on' => array(
      'imagepath' => $path_stop,
      'linktext' => $stop_text,
      'togglepath' => url('timetracking/toggle/'.$entity_type.'/', array('absolute' => true)),
    ),
    'off' => array(
      'imagepath' => $path_start,
      'linktext' => $start_text,
      'togglepath' => url('timetracking/toggle/'.$entity_type.'/', array('absolute' => true)),
    ),
  );
  
  $variables['image'] = $image;
  $variables['linktext'] = $linktext;
  
  static $js_added = false;
  if (!$js_added) {
    drupal_add_js(array('timetracking' => $togglevalues), 'setting');
    $js_added = true;
  }
}

/**
* Adds timetracking javascript
*/
function _timetracking_add_track_js() {
  drupal_add_js(drupal_get_path('module', 'timetracking')."/script/timetracking_toggle.js");
}

/**
* returnd the nid from a string created by autocomplete funcitons like entity reference etc.
* @TODO: this is already placed in erpal_basic_helper. So duplicate. May be a library would be nice for such things
*/
function _timetracking_get_nid_from_autocomplete_string($autocomplete_string){

  if (is_numeric($autocomplete_string))
    return $autocomplete_string;

  preg_match('/^(?:\s*|(.*) )?\[\s*nid\s*:\s*(\d+)\s*\]$/', $autocomplete_string, $matches);
  $nid = 0;
  if (!empty($matches)) {
    //try with [nid]
    $nid = $matches[2];
  } else {
    //try with (nid)
    preg_match('/^(?:\s*|(.*) )?\(\s*(\d+)\s*\)$/', $autocomplete_string, $matches);
    $nid = 0;
    if (!empty($matches)) {
      //try with [nid]
      $nid = $matches[2];
    }
  }

  return $nid;
}
